use std::time::Instant;

use autozig::{
    autozig_export,
    ffi_types::{
        ZigBox,
        ZigBuffer,
    },
    prelude::*,
};

// Use the memory monitoring provided by the OS
#[cfg(target_os = "linux")]
fn get_memory_usage() -> usize {
    let output = std::fs::read_to_string("/proc/self/statm").unwrap();
    let parts: Vec<&str> = output.split_whitespace().collect();
    let rss_pages: usize = parts[1].parse().unwrap();
    let page_size = 4096;
    rss_pages * page_size
}

#[cfg(not(target_os = "linux"))]
fn get_memory_usage() -> usize {
    0
}

// Use autozig! macro to define Zig logic inline (Safe AutoZig Principle)
autozig! {
    const std = @import("std");

    pub const ZigBuffer = extern struct {
        ptr: [*]u8,
        len: usize,
        cap: usize,
        free_fn: ?*const fn ([*]u8, usize, usize) callconv(.c) void,
    };

    pub export fn zig_free_c(ptr: [*]u8, len: usize, cap: usize) void {
        _ = len;
        // Global allocator is defined below
        const slice = ptr[0..cap];
        allocator.free(slice);
    }

    const allocator = std.heap.c_allocator;

    export fn allocate_data(size: usize) ZigBuffer {
        const slice = allocator.alloc(u8, size) catch unreachable;
        @memset(slice, 0xAA);
        return ZigBuffer{
            .ptr = slice.ptr,
            .len = slice.len,
            .cap = slice.len,
            .free_fn = zig_free_c,
        };
    }

    export fn take_ownership(buf: ZigBuffer) void {
        if (buf.len > 0) {
            buf.ptr[0] = 0xFF;
        }
        if (buf.free_fn) |free_fn| {
            free_fn(buf.ptr, buf.len, buf.cap);
        }
    }

    ---
    // Safe Rust signatures mapping
    // Note: ZigBuffer is repr(C) so we can use it.
    // autozig! macro ensures linking.

    // We ideally want unsafe functions generated by autozig to be wrapped.
    // However, for this low-level memory test, we access the raw FFI.
    // But we avoid declaring `extern "C"` manually.

    fn allocate_data(size: usize) -> ZigBuffer;
    fn take_ownership(buf: ZigBuffer);
}

// Export Rust function safely using attribute
#[autozig_export]
pub unsafe extern "C" fn rust_free_u8(ptr: *mut u8, len: usize, cap: usize) {
    unsafe {
        let _ = Vec::from_raw_parts(ptr, len, cap);
    }
}

fn run_iteration() {
    // 1. Zig Allocation -> Rust Drop
    // Safe Usage Wrapper Phase
    let raw_buf = allocate_data(1024);
    let _propperly_dropped = unsafe { ZigBox::<u8>::from_raw(raw_buf) };

    // 2. Rust Allocation -> Zig Drop
    let mut data = Vec::with_capacity(1024);
    data.resize(1024, 0xBB);
    let mut manual = std::mem::ManuallyDrop::new(data);

    let buf = ZigBuffer {
        ptr: manual.as_mut_ptr(),
        len: manual.len(),
        cap: manual.capacity(),
        free_fn: Some(rust_free_u8), // rust_free_u8 is generated by macro
    };

    take_ownership(buf);
}

fn main() {
    println!("Starting Safe Leak Test (1,000,000 iterations)...");

    let start_mem = get_memory_usage();
    let start_time = Instant::now();

    for i in 0..1_000_000 {
        run_iteration();
        if i % 100_000 == 0 {
            use std::io::Write;
            print!(".");
            std::io::stdout().flush().unwrap();
        }
    }

    let duration = start_time.elapsed();
    let end_mem = get_memory_usage();
    let diff = if end_mem > start_mem {
        end_mem - start_mem
    } else {
        0
    };

    println!("\nDone in {:.2?}", duration);
    println!("Diff: {} bytes", diff);

    if diff < 1024 * 1024 {
        println!("✅ SUCCESS: No significant leak detected.");
    } else {
        println!("❌ FAILURE: Memory leaked!");
        std::process::exit(1);
    }
}
