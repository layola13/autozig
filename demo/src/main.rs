//! Demo of AutoZig - Safe Rust to Zig FFI
//!
//! This example shows how to embed Zig code directly in Rust
//! and call it safely without any unsafe blocks!

use autozig::prelude::*;

// Example 1: Simple computation with IDL-driven FFI
autozig! {
    // Zig implementation
    const std = @import("std");
    
    export fn compute_hash(ptr: [*]const u8, len: usize) u64 {
        const data = ptr[0..len];
        var hash: u64 = 0;
        for (data) |byte| {
            hash +%= byte;
        }
        return hash;
    }
    
    export fn add_numbers(a: i32, b: i32) i32 {
        return a + b;
    }
    
    export fn multiply(a: f64, b: f64) f64 {
        return a * b;
    }
    
    ---
    
    // Rust function signatures (IDL for FFI generation)
    fn compute_hash(ptr: *const u8, len: usize) -> u64;
    fn add_numbers(a: i32, b: i32) -> i32;
    fn multiply(a: f64, b: f64) -> f64;
}

fn main() {
    println!("=== AutoZig Demo ===\n");
    
    // Example 1: Simple integer math (using safe wrapper)
    println!("1. Simple Addition:");
    let result = add_numbers(10, 32);
    println!("   10 + 32 = {}", result);
    
    // Example 2: Floating point (using safe wrapper)
    println!("\n2. Multiplication:");
    let result = multiply(3.14, 2.0);
    println!("   3.14 * 2.0 = {}", result);
    
    // Example 3: String hashing (using safe wrapper)
    println!("\n3. Hash Computation:");
    let message = b"Hello from AutoZig!";
    let hash = compute_hash(message.as_ptr(), message.len());
    println!("   Hash of '{}': {}",
             String::from_utf8_lossy(message),
             hash);
    
    println!("\n=== Demo Complete ===");
    println!("\n✅ All calls use safe wrappers generated by autozig! macro");
    println!("✅ No bindgen required - IDL-driven FFI generation");
    println!("✅ Zig code compiled with target mapping and incremental optimization");
}